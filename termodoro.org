
* Termodoro: the macOS terminal app to help you keep track of your time
  Termodoro is as stepping stone to a bunch of other console based apps
  that I want to write. Termodoro is written by entering VT100 terminal
  commands by hand to give me practice understanding how the terminal
  works, and it also seems like a simple project to practice multithreading
  with.

  I read a slideshow my john ousterhout that claimed that a programmer
  should avoid threads at most costs. Ousterhout claims that only a very
  few people are really qualified to write threaded code, and they're
  basically programming wizards. Perhaps this is arrogance, but I want to
  become a programming wizard.

  His presentation was dated 1995, so I wonder if it still holds. He claims
  that using events is much safer and easier alternative, and that for long
  running computations, you should spawn processes. I'm probably using
  threads for a bad reason here: UI asynchrony, but it's fun.

** Coding Style
   I will be using the same coding style as a certain St. Paul based
   medical devices company. It's a pretty good style. Makes the code nice
   and readable.

   variables are all snake_case
   functions are all CamelCase (with the exception of Main)
   macros and constant variables are all ALL_CAPS_SNAKE_CASE
   data types (structures and typedefs) are CamelCase.
   lines will not exceed 90 characters, and shoot for less than 80.
   
   for functions with lots of paramaters, lists will match up with the left
   parenthesis.
* Architecture

  termodoro is a multithreaded application. This is not for efficiency
  gains (other than avoiding polling) but rather because it makes handling
  asynchronous i/o more straightforward. Primarily output, though.

  The biggest issue is the timer. Putting the timer in a separate thread
  presents a huge simplification of the design, rather than needing to
  treat the timer incrementing by one second as a separate event. That
  would mean, like, polling. Yuck.

  I would not attempt doing it this way of I was dealing with any kind of
  library that wasn't completely thread-documented.
  
* Implementation
  
** Threads

   If this was a text editor, then I would probably use processes instead,
   one process per buffer, and each buffer gets its own Lua/Commander
   intepreter.

   But this is not a text editor, and I don't like dealing with ipc just yet.

*** Some Notes about threading
    For thread safety, there's a very good reason why we try to not have
    state incorporated into the queue. We'd prefer only having one thread
    writing to the queue.

  
*** timer
    This thread handles writing to the displayLine the time

    
*** keyboardListener
    Adds anything it captures from the keyboard
    to an input queue that inputProcessor thread takes from while there's
    data in the queue.

    this could probably be called something else.

** Data
*** screen_state
    Any sort of state that gets reflected on the screen directly is stored
    in the  screen_state structure.
    
**** Window Size
     When TimeTracker comes about, I'll need to handle SIGWINCH, but I don't
     see much utility in doing so at this point.

     Instead, for now, all I plan in doing is assuming that the size of the
     screen is static 80x24. Like pesky unresizable desktop apps.
   
**** cursor position (just x)
      This is used when entering a command. Of course, C-f and C-b are the
      default. These should be configurable by the user by entering a
      command.

      NOTE it may be tricky to write an insertion algorithm, but good
      practice for when I finally feel ready to tackle maxim

**** screen_buffer
     holds the current contents of the screen. This is constructed and drawn
     to the screen every time updateScreen is called. As such, it must be
     thread safe.

*** input queue

     for simplicity, if front = back that means that the queue is empty. if
     back = front - 1, that means the queue is full.

     this means that back always points to the location where (if the queue
     isn't full, it's going to put the next queued element.

     this also means that front always points to the element that is next to
     be dequeued unless the queue is empty

     
*** display line
    the display line is designed to be an ascii art large form of the
    amount of time on the clock. e.g.
    "12345" would be rendered as
    
    #+begin_src text
       $$    $$$   $$$     $  $$$$$ 
      $$$   $$ $$ $  $$   $$  $   $ 
      $$$       $     $  $ $  $     
       $$      $$   $$  $  $  $$$$  
       $$     $$     $$ $  $  $  $$ 
       $$    $$       $ $$$$$     $ 
      $$$$  $$    $  $$    $  $$ $$ 
      $$$$  $$$$$  $$$     $   $$$
    #+end_src

    The font is created by filling a structure.

    TODO: This should maybe be configured by loading the data from a text
    file.

    
*** Configuration
    I was debating this for a while, but I think it would be a good idea to
    have the small amount of configuration that the user can do be stored
    in a file.

    The defaults are hard coded, and if a home folder configuration file is
    not available, it creates one and puts all the default configuration
    settings in it. On exit, if the configuration has been changed, it
    moves the previous config file to a backup directory and writes the
    current configuration to a new file and puts it in the home folder.

    The next question is, of course, what things go into this
    configuration?

    - defaults:
      - time for a pomodoro
      - time for a break
      - time for long break
      - behavior on end of pomodoro or break
    - Shortcuts:
      - begin pomodoro
      - begin short break
      - begin long break
      - enter command
      - exit
      - view help document.
      - add description of activity
      - export log to csv


    After answering that, we need to get the format down. Ideally, we use a
    grammar that is extremely easy to parse

    I think that this will serve as a default

    #+begin_src text
      pomodoro_length_seconds 1500 
      pomodoro_short_break_length_seconds 300
      pomodoro_long_break_length_seconds 1200
      pomodoro_set_length 4
      default_session_pomodoro_goal 15

      continue_tracking_time_upon_completion true
      auto_start_short_breaks false
      auto_start_long_breaks false

      show_big_time true
      show_small_time true
      show_time_logged_so_far true
      show_time_left true

      exit_shortcut e
      begin_pomodoro_shortcut p
      begin_short_break_shortcut s
      begin_long_break_shortcut l
      enter_command_shortcut c
      previous_char_shortcut b
      next_char_shortcut f
      view_help_document_shortcut h

      alert_with_audio true
      alert_audio_file watch_alarm.wav

    #+end_src

** Behavior
*** Drawing to the screen
    A sepaarate thread is in control of actually drawing to the screen. A
    thread sends a request for a screen redraw by using that was actually a
    terrible idea. There was no telling when the scheduler would actually
    decide to run that thread, so there was tons of flickering. And
    sometimes it straight up wouldn't do it.
   
    There should definitely be a more robust system for building the screen
    layout, and I think I'm going to take the
   
    screen buffer idea and have a function that builds the screen each time.
    I was hoping that it would be possible not to do it that way, but oh
    well. I was hoping that we'd be able to only need to redraw one or two
    lines at a time, but I'm not sure it can be helped.
   
    two functions are required: build output buffer, redraw screen.

    build output buffer doesn't need to take any paramaters. It uses the
    current state of the program to do that. It requires a mutex on every
    single element that affects the elements currently displayed on the
    screen. I'm not sure if that means that it should have a unique mutex
    for every screen element, or if it should instead have only one
    stdout_mutex.
   
    redraw screen will probably be the only function that calls build output
    buffer. I don't see a point in having other functions call it. I mean,
    obviously, you'd probably want to display any changes you made to the
    output buffer immediately on the screen.
   
    Perhaps there should be a few other functions to help handle outputting
    data onto the screen. I already have a displayline element that is
    accessed only through functions. Perhaps every element that gets drawn
    to the screen should only be accessible through setter functions.

    In which case, there should instead of being terminal state structures,
    but two. One is for application state (model) and the other is for
    display state (view). I guess that mvc once more prevails.

    I have to wonder, however, why threads didn't work. I was probably
    misusing signals, really. Maybe signals aren't fast enough.

    Lastly, I'll need to rewrite this in nCurses. That will undoubtedly help
    with the portability. Using only VT100 is probably fine for the most
    part, but I think that using an actual library that's so well developed
    would speak better to prospective employers that are interested in
    looking up my work. Being able to use libraries is a great skill.
   
*** Processing input

    this is a toughy. I guess there should be a master thread to coordinate
    between threads. It would just call functions based on non-display
    characters that it receives.
   
    the question: when they enter command mode, should processInput hand it
    off to a different function to handle getting the command, or should
    process input do it internally?
   
    I guess it makes sense to delegate grabbing command input to a different
    function.

    Shortcuts:

    #+begin_src text
      C-p ..... begin pomodoro
      C-s ..... begin short break
      C-l ..... begin long break
      C-c ..... enter a command
      C-h ..... open help document with less
    #+end_src

    lessons learned over the last few days of hacking away at this:

*** Commands
    
**** list of commands
     
***** set
      set is used to set configuration paramater. Any variable that affects
      the behavior of app.

***** save_configuration
      this will write the current configuration variables to the
      configuration file in the home folder (.termodoro)
** Algorithms
*** Command Line capture

    I'm an efficiency nut. I do not like the idea of having to move each
    character over each keypress. 
    
   
